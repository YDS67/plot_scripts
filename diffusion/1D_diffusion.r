# Моделирование диффузии
# Единицы измерения см и сек

# Числовые параметры

#================================
# Параметры задачи (физические)
#================================
# Коэффициент диффузии
D <- 1 # cm^2/sec
# Число частиц
n0 <- 10000

#================================
# Параметры расчётной модели
#================================
# Конечное время
T <- 1 #sec
# Граничное расстояние
a <- 6 #cm
L <- sqrt(D * T) # diffusion length, cm

#================================
# Параметры конечно-разностной схемы
#================================
dz <- 0.1 #cm
J <- floor(a/dz)
zj <- (-J):J * dz
dt <- 0.002 #sec
Q <- floor(T/dt)
V <- D * dt / dz^2

#================================
# Параметры случайного блуждания
#================================
# Шаг по координате
bz <- 0.2 #cm
K <- floor(a/bz)
zk <- (-K):K * bz
# Шаг по времени выбираем с учётом величины коэффициента диффузии
bt <- bz^2/D/2
# Число частиц берём такое же, как в начале (n0)
#Число шагов случайного блуждания определяется Т
M <- floor(T/bt)

#================================
# Задаём точное решение
#================================
n_exact <- function(z,t){n0 * exp(-z^2/(4*D*t))/sqrt(4*pi*D*t)}

#================================
# Метод случайного блуждания
#================================
# Задаём вектор положений частиц и его начальное значение
x <- rep(0, n0)

# Цикл по времени
for (jt in 1:M) {
  # Цикл по частицам
  for (jn in 1:n0) {
    # Случайный скачок направо или налево
    x[jn] <- x[jn] + sample(c(-1,1),1)
  }
}

# !!! Дополнительный шаг по времени для половины частиц
for (jn in 1:floor(n0/2)) {
    # Случайный скачок направо или налево
    x[jn] <- x[jn] + sample(c(-1,1),1)
}

# Вводим функцию распеределения частиц
nk <- rep(0, 2*K + 1)

# Цикл по частицам
for (jn in 1:n0) {
  if (x[jn] >= -K && x[jn] <= K) {
    nk[x[jn]+K+1] <- nk[x[jn]+K+1] + 1
  }
}

nk <- nk/bz

#================================
# Метод конечных разностей
#================================

# Распреледение концентрации в момент времени q
nq <- rep(0, 2*J + 1)
# Распреледение концентрации в момент времени q+1
nq1 <- rep(0, 2*J + 1)

# Используем начальное условие:

nq[J+1] <- n0 / dz

# Вектор, соответствующий точкам сетки



# Схема Эйлера, цикл по времени

for (q in 1:Q){

# Цикл по координате

# Cначала для левой граничной точки:

nq1[1] <- nq[1] + V * (0 - 2*nq[1] + nq[2])

# Потом для всех остальных, кроме самой правой

for (j in 2:(2*J)){
	nq1[j] <- nq[j] + V * (nq[j-1] - 2*nq[j] + nq[j+1])
}

# Для самой правой точки

nq1[2*J + 1] <- nq[2*J + 1] + V * (nq[2*J] - 2*nq[2*J + 1] + 0)

# Обновляем значение вектора:

nq <- nq1

}

#================================
# Экспорт данных
#================================

# Сохраняем результаты отдельно для конечных разностей (плюс точная формула)
# и для случайного блуждания, т.к. количество точек может быть разное, и в одну таблицу это не поместить

FD_data <- data.frame(zj, n_exact(zj, T), nq)
RW_data <- data.frame(zk, nk)

write.table(FD_data, "data/diffusion_results_FD.dat", col.names = FALSE, row.names = FALSE)
write.table(RW_data, "data/diffusion_results_RW.dat", col.names = FALSE, row.names = FALSE)

#================================
# Построение графиков
#================================

# Не строим график, для этого есть отдельные скрипты
